#!/usr/bin/env node
/**
 * Style Dictionary token build script
 * Loads base tokens, merges with brand overrides, outputs:
 *   brands/<name>/tokens.json  — flat key-value for runtime consumption
 *   brands/<name>/tokens.css   — CSS custom properties
 *
 * No external dependencies required. Run with: node tokens/build.js
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs'
import { join, dirname } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const projectRoot = dirname(__dirname)

const BRANDS = ['givecare', 'scty', 'disney-tips']

/**
 * Deep merge objects (brand overrides base)
 */
function deepMerge(base, override) {
  const result = { ...base }
  for (const key of Object.keys(override)) {
    if (
      override[key] !== null &&
      typeof override[key] === 'object' &&
      !Array.isArray(override[key]) &&
      base[key] !== null &&
      typeof base[key] === 'object' &&
      !Array.isArray(base[key])
    ) {
      result[key] = deepMerge(base[key], override[key])
    } else {
      result[key] = override[key]
    }
  }
  return result
}

/**
 * Flatten W3C design token tree to key-value pairs.
 * Leaf nodes have a `$value` property.
 * Keys are dot-separated paths: color.background, typography.headline.font, etc.
 */
function flattenTokens(node, prefix = '', out = {}) {
  if (node && typeof node === 'object' && '$value' in node) {
    out[prefix] = node.$value
    return out
  }
  for (const key of Object.keys(node)) {
    if (key.startsWith('$')) continue // skip $type, $description, etc.
    const path = prefix ? `${prefix}.${key}` : key
    flattenTokens(node[key], path, out)
  }
  return out
}

/**
 * Convert dot-key to CSS custom property name.
 * color.background → --color-background
 * typography.headline.scaleFactorLarge → --typography-headline-scale-factor-large
 */
function toCSSVar(key) {
  return '--' + key
    .replace(/\./g, '-')
    .replace(/([A-Z])/g, '-$1')
    .toLowerCase()
    .replace(/--+/g, '-')
}

/**
 * Build tokens for a single brand
 */
function buildBrand(brandName) {
  const baseTokens = JSON.parse(readFileSync(join(__dirname, 'base.json'), 'utf-8'))
  const brandTokenPath = join(__dirname, 'brands', `${brandName}.json`)

  let merged = baseTokens
  if (existsSync(brandTokenPath)) {
    const brandTokens = JSON.parse(readFileSync(brandTokenPath, 'utf-8'))
    merged = deepMerge(baseTokens, brandTokens)
  } else {
    console.warn(`  [warn] No brand token file for ${brandName}, using base only`)
  }

  const flat = flattenTokens(merged)

  // Output directory: brands/<name>/ (relative to project root)
  const outDir = join(projectRoot, 'brands', brandName)
  if (!existsSync(outDir)) {
    mkdirSync(outDir, { recursive: true })
  }

  // tokens.json — flat key-value
  const jsonPath = join(outDir, 'tokens.json')
  writeFileSync(jsonPath, JSON.stringify(flat, null, 2), 'utf-8')

  // tokens.css — CSS custom properties
  const cssLines = [
    `/* Brand: ${brandName} — generated by tokens/build.js */`,
    `:root {`,
    ...Object.entries(flat).map(([k, v]) => `  ${toCSSVar(k)}: ${v};`),
    `}`,
    '',
  ]
  const cssPath = join(outDir, 'tokens.css')
  writeFileSync(cssPath, cssLines.join('\n'), 'utf-8')

  console.log(`  ✓ ${brandName}: ${Object.keys(flat).length} tokens → tokens.json + tokens.css`)
  return flat
}

// Build all brands
console.log('\nBuilding design tokens...\n')
let totalErrors = 0

for (const brand of BRANDS) {
  try {
    buildBrand(brand)
  } catch (err) {
    console.error(`  ✗ ${brand}: ${err.message}`)
    totalErrors++
  }
}

if (totalErrors === 0) {
  console.log('\nDone. All brands built successfully.\n')
} else {
  console.error(`\nDone with ${totalErrors} error(s).\n`)
  process.exit(1)
}
